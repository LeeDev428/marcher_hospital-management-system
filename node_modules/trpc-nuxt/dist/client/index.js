import { defaultEndpoint } from "../shared-C-gde89n.js";
import { createTRPCClientProxy, createTRPCUntypedClient, httpBatchLink as httpBatchLink$1, httpBatchStreamLink as httpBatchStreamLink$1, httpLink as httpLink$1 } from "@trpc/client";
import { createTRPCFlatProxy, createTRPCRecursiveProxy } from "@trpc/server";
import { useAsyncData, useRequestHeaders } from "nuxt/app";
import { getCurrentInstance, isRef, onScopeDispose, shallowRef, toRaw, toValue } from "vue";
import { hash } from "ohash";

//#region src/client/getQueryKey.ts
function getQueryKeyInternal(path, input) {
	return input === void 0 ? path : `${path}-${hash(input || "")}`;
}
/**
* Method to extract the query key for a procedure
* @param procedure - procedure
* @param input - input to procedure
* @see https://trpc-nuxt.pages.dev/guides/mutation-and-revalidation
*/
function getQueryKey(procedureOrRouter, ..._params) {
	const [input] = _params;
	const path = procedureOrRouter._def().path;
	const dotPath = path.join(".");
	return getQueryKeyInternal(dotPath, input);
}
function getMutationKeyInternal(path) {
	return getQueryKeyInternal(path, void 0);
}
/**
* Method to extract the mutation key for a procedure
* @param procedure - procedure
* @see https://trpc-nuxt.pages.dev/guides/mutation-and-revalidation
*/
function getMutationKey(procedure) {
	const path = procedure._def().path;
	const dotPath = path.join(".");
	return getMutationKeyInternal(dotPath);
}

//#endregion
//#region src/client/decorationProxy.ts
function isRefOrGetter(val) {
	return isRef(val) || typeof val === "function";
}
function createAbortController(trpc) {
	let controller;
	if (trpc?.abortOnUnmount) {
		if (getCurrentInstance()) onScopeDispose(() => {
			controller?.abort?.();
		});
		controller = typeof AbortController !== "undefined" ? new AbortController() : {};
	}
	return controller;
}
function createNuxtProxyDecoration(name, client) {
	return createTRPCRecursiveProxy((opts) => {
		const args = opts.args;
		const pathCopy = [name, ...opts.path];
		const lastArg = pathCopy.pop();
		const path = pathCopy.join(".");
		const [input, otherOptions] = args;
		if (lastArg === "_def") return { path: pathCopy };
		if (lastArg === "useQuery") {
			const { trpc, queryKey: customQueryKey,...asyncDataOptions } = otherOptions || {};
			const controller = createAbortController(trpc);
			const queryKey = customQueryKey || getQueryKeyInternal(path, toValue(input));
			const watch = isRefOrGetter(input) ? [...asyncDataOptions.watch || [], input] : asyncDataOptions.watch;
			return useAsyncData(queryKey, () => client[path].query(toValue(input), {
				signal: controller?.signal,
				...trpc
			}), {
				...asyncDataOptions,
				watch
			});
		}
		if (lastArg === "useMutation") {
			const { trpc, mutationKey: customMutationKey,...asyncDataOptions } = otherOptions || {};
			const input$1 = shallowRef(null);
			const controller = createAbortController(trpc);
			const mutationKey = customMutationKey || getMutationKeyInternal(path);
			const asyncData = useAsyncData(mutationKey, () => client[path].mutate(toRaw(input$1.value), {
				signal: controller?.signal,
				...trpc
			}), {
				...asyncDataOptions,
				lazy: false,
				server: false,
				immediate: false
			});
			async function mutate(value) {
				input$1.value = value;
				await asyncData.execute();
				return toRaw(asyncData.data.value);
			}
			Object.assign(asyncData, { mutate });
			return asyncData;
		}
		return client[path][lastArg](...args);
	});
}

//#endregion
//#region src/client/createTRPCNuxtClient.ts
function createTRPCNuxtClient(opts) {
	const client = createTRPCUntypedClient(opts);
	const proxy = createTRPCClientProxy(client);
	const decoratedClient = createTRPCFlatProxy((key) => {
		return createNuxtProxyDecoration(key, proxy);
	});
	return decoratedClient;
}

//#endregion
//#region src/client/links.ts
function isFetchError(error) {
	return error instanceof Error && error.name === "FetchError";
}
function createCustomFetch(fetchOptions) {
	return async function customFetch(input, init) {
		return globalThis.$fetch.create(fetchOptions ?? {}).raw(input.toString(), init).catch((e) => {
			if (isFetchError(e) && e.response) return e.response;
			throw e;
		}).then((response) => ({
			...response,
			headers: response.headers,
			json: () => Promise.resolve(response._data)
		}));
	};
}
function createDefaultLinkOptions(params) {
	const headers = useRequestHeaders(params.pickHeaders);
	return {
		url: defaultEndpoint,
		headers() {
			return headers;
		},
		fetch: createCustomFetch(params.fetchOptions)
	};
}
/**
* This is a convenience wrapper around the original httpLink
* that replaces regular `fetch` with a `$fetch` from Nuxt. It
* also sets the default headers based on `useRequestHeaders` values.
*
* During server-side rendering, calling $fetch to fetch your internal API routes
* will directly call the relevant function (emulating the request),
* saving an additional API call.
*
* @see https://nuxt.com/docs/api/utils/dollarfetch
*/
function httpLink(opts) {
	return httpLink$1({
		...createDefaultLinkOptions({
			pickHeaders: opts?.pickHeaders,
			fetchOptions: opts?.fetchOptions
		}),
		...opts
	});
}
/**
* This is a convenience wrapper around the original httpBatchLink
* that replaces regular `fetch` with a `$fetch` from Nuxt. It
* also sets the default headers based on `useRequestHeaders` values.
*
* During server-side rendering, calling $fetch to fetch your internal API routes
* will directly call the relevant function (emulating the request),
* saving an additional API call.
*
* @see https://nuxt.com/docs/api/utils/dollarfetch
*/
function httpBatchLink(opts) {
	return httpBatchLink$1({
		...createDefaultLinkOptions({
			pickHeaders: opts?.pickHeaders,
			fetchOptions: opts?.fetchOptions
		}),
		...opts
	});
}
/**
* This is a convenience wrapper around the original httpBatchStreamLink
* that replaces regular `fetch` with a `$fetch` from Nuxt. It
* also sets the default headers based on `useRequestHeaders` values.
*
* During server-side rendering, calling $fetch to fetch your internal API routes
* will directly call the relevant function (emulating the request),
* saving an additional API call.
*
* @see https://nuxt.com/docs/api/utils/dollarfetch
*/
function httpBatchStreamLink(opts) {
	return httpBatchStreamLink$1({
		...createDefaultLinkOptions({
			pickHeaders: opts?.pickHeaders,
			fetchOptions: opts?.fetchOptions
		}),
		...opts
	});
}

//#endregion
export { createTRPCNuxtClient, getMutationKey, getQueryKey, httpBatchLink, httpBatchStreamLink, httpLink };