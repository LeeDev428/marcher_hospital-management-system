import * as _trpc_client2 from "@trpc/client";
import { CreateTRPCClientOptions, HTTPBatchLinkOptions, HTTPLinkOptions, OperationContext, TRPCClientError, TRPCClientErrorLike, TRPCProcedureOptions, TRPCRequestOptions } from "@trpc/client";
import { AnyTRPCProcedure, AnyTRPCRootTypes, AnyTRPCRouter, TRPCProcedureType, inferProcedureInput, inferTransformedProcedureOutput } from "@trpc/server";
import { AsyncData, AsyncDataOptions } from "nuxt/app";
import { MaybeRefOrGetter, UnwrapRef } from "vue";
import { TRPCConnectionState } from "@trpc/client/unstable-internals";
import { Unsubscribable } from "@trpc/server/observable";
import { DeepPartial, RouterRecord, inferAsyncIterableYield } from "@trpc/server/unstable-core-do-not-import";
import { FetchOptions } from "ofetch";

//#region src/client/createTRPCNuxtClient.d.ts
type PickFrom<T, K extends Array<string>> = T extends Array<any> ? T : T extends Record<string, any> ? keyof T extends K[number] ? T : K[number] extends never ? T : Pick<T, K[number]> : T;
type KeysOf<T> = Array<T extends T ? keyof T extends string ? keyof T : never : never>;
interface ResolverDef {
  input: any;
  output: any;
  transformer: boolean;
  errorShape: any;
}
interface TRPCSubscriptionObserver<TValue, TError> {
  onStarted: (opts: {
    context: OperationContext | undefined;
  }) => void;
  onData: (value: inferAsyncIterableYield<TValue>) => void;
  onError: (err: TError) => void;
  onStopped: () => void;
  onComplete: () => void;
  onConnectionStateChange: (state: TRPCConnectionState<TError>) => void;
}
type SubscriptionResolver<TDef extends ResolverDef> = (input: TDef['input'], opts?: Partial<TRPCSubscriptionObserver<TDef['output'], TRPCClientError<TDef>>> & TRPCProcedureOptions) => Unsubscribable;
type DecorateProcedure<TType extends TRPCProcedureType, TDef extends ResolverDef> = TType extends 'query' ? DecoratedQuery<TDef> : TType extends 'mutation' ? DecoratedMutation<TDef> : TType extends 'subscription' ? {
  subscribe: SubscriptionResolver<TDef>;
} : never;
type DecorateRouterRecord<TRoot extends AnyTRPCRootTypes, TRecord extends RouterRecord> = { [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value ? $Value extends RouterRecord ? DecorateRouterRecord<TRoot, $Value> : $Value extends AnyTRPCProcedure ? DecorateProcedure<$Value['_def']['type'], {
  input: inferProcedureInput<$Value>;
  output: inferTransformedProcedureOutput<TRoot, $Value>;
  transformer: TRoot['transformer'];
  errorShape: TRoot['errorShape'];
}> : never : never };
type Resolver<TDef extends ResolverDef> = (input: TDef['input'], opts?: TRPCProcedureOptions) => Promise<TDef['output']>;
interface DecoratedQuery<TDef extends ResolverDef> {
  /**
   * @example
   *
   * const { data } = await $trpc.todo.getTodos.useQuery()
   */
  useQuery: <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData, PickKeys extends KeysOf<TData> = KeysOf<TData>>(input: MaybeRefOrGetter<TDef['input']>, opts?: Omit<AsyncDataOptions<TQueryFnData, TData, PickKeys>, 'watch'> & {
    /**
     * The custom unique key to use.
     * @see https://nuxt.com/docs/api/composables/use-async-data#params
     */
    queryKey?: string;
    watch?: AsyncDataOptions<TQueryFnData, TData, PickKeys>['watch'] | false;
    trpc?: TRPCRequestOptions;
  }) => AsyncData<PickFrom<TData, PickKeys> | null, TRPCClientErrorLike<TDef>>;
  query: Resolver<TDef>;
}
interface DecoratedMutation<TDef extends ResolverDef> {
  /**
   * @example
   *
   * const { mutate } = $trpc.todo.addTodo.useMutation()
   * mutate({ text: 'migrate to TRPC v11', completed: false })
   */
  useMutation: <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData, PickKeys extends KeysOf<TData> = KeysOf<TData>>(opts?: Omit<AsyncDataOptions<TQueryFnData, TData, PickKeys>, 'lazy' | 'watch' | 'server' | 'immediate'> & {
    /**
     * The custom unique key to use.
     * @see https://nuxt.com/docs/api/composables/use-async-data#params
     */
    mutationKey?: string;
    trpc?: TRPCRequestOptions;
  }) => AsyncData<PickFrom<TData, PickKeys> | null, TRPCClientErrorLike<TDef>> & {
    /**
     * The function to call to trigger the mutation.
     */
    mutate: (input: TDef['input']) => Promise<UnwrapRef<AsyncData<PickFrom<TData, PickKeys> | null, TRPCClientErrorLike<TDef>>['data']>>;
  };
  mutate: Resolver<TDef>;
}
declare function createTRPCNuxtClient<TRouter extends AnyTRPCRouter>(opts: CreateTRPCClientOptions<TRouter>): DecorateRouterRecord<TRouter["_def"]["_config"]["$types"], TRouter["_def"]["record"]>;
//#endregion
//#region src/client/getQueryKey.d.ts
type ProcedureOrRouter = DecoratedMutation<any> | DecoratedQuery<any> | DecorateRouterRecord<any, any>;
/** @internal */
type GetQueryProcedureInput<TProcedureInput> = DeepPartial<TProcedureInput> | undefined;
type GetParams<TProcedureOrRouter extends ProcedureOrRouter> = TProcedureOrRouter extends DecoratedQuery<infer $Def> ? [input?: GetQueryProcedureInput<$Def['input']>] : [];
/**
 * Method to extract the query key for a procedure
 * @param procedure - procedure
 * @param input - input to procedure
 * @see https://trpc-nuxt.pages.dev/guides/mutation-and-revalidation
 */
declare function getQueryKey<TProcedureOrRouter extends ProcedureOrRouter>(procedureOrRouter: TProcedureOrRouter, ..._params: GetParams<TProcedureOrRouter>): string;
/**
 * Method to extract the mutation key for a procedure
 * @param procedure - procedure
 * @see https://trpc-nuxt.pages.dev/guides/mutation-and-revalidation
 */
declare function getMutationKey<TProcedure extends DecoratedMutation<any>>(procedure: TProcedure): string;
//#endregion
//#region src/client/links.d.ts
interface DefaultLinkOptionsParams {
  /**
   * Select headers to pass to `useRequestHeaders`.
   */
  pickHeaders?: string[];
  /**
   * ofetch fetch options.
   * @see https://github.com/unjs/ofetch
   */
  fetchOptions?: FetchOptions;
}
type HTTPLinkOptions$1<TRouter extends AnyTRPCRouter> = HTTPLinkOptions<TRouter['_def']['_config']['$types']> & DefaultLinkOptionsParams;
/**
 * This is a convenience wrapper around the original httpLink
 * that replaces regular `fetch` with a `$fetch` from Nuxt. It
 * also sets the default headers based on `useRequestHeaders` values.
 *
 * During server-side rendering, calling $fetch to fetch your internal API routes
 * will directly call the relevant function (emulating the request),
 * saving an additional API call.
 *
 * @see https://nuxt.com/docs/api/utils/dollarfetch
 */
declare function httpLink<TRouter extends AnyTRPCRouter = AnyTRPCRouter>(opts?: HTTPLinkOptions$1<TRouter>): _trpc_client2.TRPCLink<AnyTRPCRouter>;
type HttpBatchLinkOptions<TRouter extends AnyTRPCRouter> = HTTPBatchLinkOptions<TRouter['_def']['_config']['$types']> & DefaultLinkOptionsParams;
/**
 * This is a convenience wrapper around the original httpBatchLink
 * that replaces regular `fetch` with a `$fetch` from Nuxt. It
 * also sets the default headers based on `useRequestHeaders` values.
 *
 * During server-side rendering, calling $fetch to fetch your internal API routes
 * will directly call the relevant function (emulating the request),
 * saving an additional API call.
 *
 * @see https://nuxt.com/docs/api/utils/dollarfetch
 */
declare function httpBatchLink<TRouter extends AnyTRPCRouter>(opts?: HttpBatchLinkOptions<TRouter>): _trpc_client2.TRPCLink<AnyTRPCRouter>;
/**
 * This is a convenience wrapper around the original httpBatchStreamLink
 * that replaces regular `fetch` with a `$fetch` from Nuxt. It
 * also sets the default headers based on `useRequestHeaders` values.
 *
 * During server-side rendering, calling $fetch to fetch your internal API routes
 * will directly call the relevant function (emulating the request),
 * saving an additional API call.
 *
 * @see https://nuxt.com/docs/api/utils/dollarfetch
 */
declare function httpBatchStreamLink<TRouter extends AnyTRPCRouter>(opts?: HttpBatchLinkOptions<TRouter>): _trpc_client2.TRPCLink<AnyTRPCRouter>;
//#endregion
export { createTRPCNuxtClient, getMutationKey, getQueryKey, httpBatchLink, httpBatchStreamLink, httpLink };